%
% Layout retirado de http://www.di.uminho.pt/~prh/curplc09.html#notas
%
\documentclass{report}
\usepackage[portuges]{babel}
%\usepackage[utf8]{inputenc}
\usepackage[latin1]{inputenc}
\usepackage{graphicx}

\usepackage{url}
%\usepackage{alltt}
%\usepackage{fancyvrb}
\usepackage{listings}
%LISTING - GENERAL
\lstset{
	basicstyle=\small,
	numbers=left,
	numberstyle=\tiny,
	numbersep=5pt,
	breaklines=true,
    frame=tB,
	mathescape=true,
	escapeinside={(*@}{@*)}
}
%
%\lstset{ %
%	language=Java,							% choose the language of the code
%	basicstyle=\ttfamily\footnotesize,		% the size of the fonts that are used for the code
%	keywordstyle=\bfseries,					% set the keyword style
%	%numbers=left,							% where to put the line-numbers
%	numberstyle=\scriptsize,				% the size of the fonts that are used for the line-numbers
%	stepnumber=2,							% the step between two line-numbers. If it's 1 each line
%											% will be numbered
%	numbersep=5pt,							% how far the line-numbers are from the code
%	backgroundcolor=\color{white},			% choose the background color. You must add \usepackage{color}
%	showspaces=false,						% show spaces adding particular underscores
%	showstringspaces=false,					% underline spaces within strings
%	showtabs=false,							% show tabs within strings adding particular underscores
%	frame=none,								% adds a frame around the code
%	%abovecaptionskip=-.8em,
%	%belowcaptionskip=.7em,
%	tabsize=2,								% sets default tabsize to 2 spaces
%	captionpos=b,							% sets the caption-position to bottom
%	breaklines=true,						% sets automatic line breaking
%	breakatwhitespace=false,				% sets if automatic breaks should only happen at whitespace
%	title=\lstname,							% show the filename of files included with \lstinputlisting;
%											% also try caption instead of title
%	escapeinside={\%*}{*)},					% if you want to add a comment within your code
%	morekeywords={*,...}					% if you want to add more keywords to the set
%}

\usepackage{xspace}

\parindent=0pt
\parskip=2pt

\setlength{\oddsidemargin}{-1cm}
\setlength{\textwidth}{18cm}
\setlength{\headsep}{-1cm}
\setlength{\textheight}{23cm}

\def\darius{\textsf{Darius}\xspace}
\def\java{\texttt{Java}\xspace}
\def\pe{\emph{Publicação Eletrónica}\xspace}

%%%%\input{LPgeneralDefintions}

\title{Processamento de linguagens  (3º ano de MIEI)\\ \textbf{Trabalho Prático 1}\\ Relatório de Desenvolvimento}
\author{Célia Figueiredo\\ (a67637) \and Diogo Tavares\\ (a61044)\\  \and Gil Gonçalves \\ (a67738) }
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
	
Neste relatório será apresentado o desenvolvimento de um filtro de texto com a posterior aplicação sob um ficheiro BibTex, pretende-se que seja produzido um normalizador de ficheiros BibTex. 

Implementou-se um filtro que permite fazer a contagem das categorias das referências bibliográficas, também foi implementado um filtro que permite a troca para chavetas do campo que está entre aspas. E ainda foi implementado um filtro que coloca os nomes dos autores escritos no formato "N. Apelido". Por fim, de modo a tornar a leitura mais fácil implementou-se um ferramenta de \textit{pretty-printing}. 

Será também mostrado um grafo que ilustra para um dado autor (escolhido pelo utilizador) todos os autores que publicam normalmente com o autor em causa. Utilizou-se a linguagem \textit{Dot} do \textit{ GraphViz} esta, que gerou um ficheiro com um grafo de modo a que posteriormente fosse usada uma das ferramentas que processam \textit{Dot} para desenhar o dito grafo de associações de autores.

\end{abstract}

\tableofcontents

\chapter{Introdução} \label{intro}

Este trabalho envolverá o desenvolvimento de um normalizador de ficheiros \textit{BibTex}, este é o tema do problema 2.2 do enunciado fornecido. 
\begin{description}
  \item [Enquadramento] Utilização de expressões regulares e filtros de texto com o objetivo de produzir novos documentos a partir de padrões existentes no ficheiro de input. 
  \item [Conteúdo do documento] O presente documento contém a explicação do problema, assim como a apresentação das soluções produzidas. 
  \item [Resultados] Os resultados deste desafio serão as alineas pedidas, sendo que serão apresentados em ficheitos \textit{.html} e grafos. 
\end{description}


\section*{Estrutura do Relatório} \
Este documentos está dividido em seis partes 
No capítulo \ref{ae} faz-se uma análise detalhada do problema proposto
de modo a poder-se especificar  as entradas, resultados e formas de transformação do ficheiro \textit{.bib}. 

No capítulo \ref{cdres} serão descritas as estruturas de dados implementadas para a realização do problema descrito. 
No capítulo \ref{codtestes} serão mostradas as expressões regulares desenvolvidas para a implementação do caso de estudo, assim como os testes realizados e os resultados. 
No capítulo~\ref{concl} termina-se o relatório com uma síntese do que foi dito,
as conclusões e o trabalho futuro. No fim do documento estará incluido ficheiros anexos com o código desenvolvido. 

\chapter{Análise e Especificação} \label{ae}
\section{Descrição informal do problema}

O problema escolhido consiste na análise da ferramenta de formatação de citações e referências bibliográficas em documentos \LaTeX. 

O \textit{BibTex} é uma ferramenta que foi criada em  1985 e utiliza um ficheiro \textit{(.bib)} este que é uma base de dados que contém os dados bibliográficos (autor, título, ano de publicação, etc.) das fontes citadas no documento \LaTeX. 

Deixámos um exemplo de um excerto de um ficheiro com a extensão \textit{.bib}: 

\begin{verbatim}
@inbook{Val90a,
author = "Jos\'e M. Valen\c{c}a",
title = "Processos, {O}bjectos e {C}omunica\c{c}\~ao
({O}p\c{c}\~ao I - {MCC})",
chapter = 2,
year = 1990,
month = Oct,
publisher = gdcc,
address = um,
annote = "programacao oobjectos, proc comunicantes, espec formal"
}
\end{verbatim}

O ficheiro BibTex contém várias categorias de referência estas inicializadas sempre pelo caracter $@$, deixamos aqui alguns exemplos de entradas que podem ser encontradas no ficheiro BibTex: 

\begin{verbatim}
@inbook
@misc
@incollection
@inproceedings
@techreport
@unpublished
\end{verbatim}

\section{Especificação do Requisitos}
\subsection{Dados}
Os dados fornecidos são um ficheiro \textit{.bib}, este que é um ficheiro com as caracteristicas de um ficheiro \textit{BibTex}. 

Cada tipo de categoria tem os seus campos obrigatórios, neste acaso o objetivo de uma das tarefas será pesquisar através do campo \textbf{author = } o nome do autor e transformá-lo no formato "N. Apelido". 

O nome da categoria é seguida por uma chaveta, e o primeiro campo será o nome para a referência a ser introduzida, os campos de cada categoria são separados por vírgula e a seguir ao campo aparecerá o simbolo igual (=), deixámos um exemplo da sintaxe da categoria \textbf{$@$phdthesis} e os respetivos campos presentes: 

\begin{verbatim}
@phdthesis{Mos75a,
author = "P. D. Mosses",
title = "Mathematical Semantics and Compiler Generation",
year = 1975,
school = "Oxford University",
annote = "compilacao incremental, atributos, ambientes prog"
}
\end{verbatim}

É também fornecido o nome de ferramentas de apoio à resolução do problema, neste caso o \textit{Graph Viz}, que permitirá colocar gráficamente a informação dos grafos criados, sendo que tornará as iterações entre os autores mais percetiveis. 


\begin{figure}[<+htpb+>]
	\centering
	\includegraphics[scale=0.5]{grafoex}
	\caption{Exemplo de geração de um grafo com os nomes dos autores com recurso à ferramenta \textit{Graph Viz} }
	\label{p1:fig:ae}
\end{figure}


\chapter{Concepção/desenho da Resolução} \label{cdres}
\section{Estruturas de Dados}


\subsection{Algoritmo alinea a)}

Nesta alinea optou-se por utilizar listas ligadas porque
vai guardando as categorias e o respetivo contador à medida que se encontra um padrão no ficheiro \textit{.bib}. 

Decidimos que as categorias que se diferenciavam apenas nas letras maiúsculas ou minúsculas pertenceriam à mesma categoria. 

\begin{verbatim}
void* procura(char* c){
int flag = 1;

Est* aux;
aux = est;
while(aux!=NULL && flag && aux->cat != NULL){
if(!strcmp(minusculas(aux->cat), minusculas(c+1))){				
aux->i++;
flag=0;
}
aux=aux->next;
}				

if(flag){
Est* novo = (Est*) malloc(sizeof(Est));
novo->cat = strdup(c+1);
novo->i = 1;
novo->next = est;
est = novo;
}
}
\end{verbatim}

\subsection{Algoritmo alinea b1)}

Utilizámos dois arrays, um que guarda a informação que é lida, e outro que guarda a informação tratada. 

O algoritmo utiliza o array nomes para modelar a informação, 
a função \textbf{void trata()} trata o nome acabado de ler, guaradando o primeiro caractere e acrescenta um ponto para os restantes, guarda também o último nome do autor. 



\subsection{Algoritmo alínea b2)}

Utilizamos arrays para guardar os nomes dos autores e quando encontra \textbf{and} insere um \textbf{$\backslash$n}, separando os nomes dos autores. 


\subsection{Algoritmo alinea c)}

Nesta alínea utilizámos arrays para guardar o nome de cada autor e escrevemo-los num ficheiro \textit{.dot}. 


\chapter{Codificação e Testes} \label{codtestes}

\section{Alternativas, Decisões e Problemas de Implementação}

\subsection{Expressões Regulares}
Para garantir que uma secção do código do ficheiro input ficassse protegida de todas as acções accionadas por outras expressões regulares declaramos o estado \%x. 

\subsubsection{Alinea a)}

Nesta alinea é pedido que se faça a contagem das categorias existentes, e no final se produza um ficheiro em formato HTML como o nome e as respetivas contagens. 

Para a realização deste desafio é necesário procurar a categoria inicializada pelo caractere $@$ até encontrar a chaveta de abertura (\{). A categoria encontrada será inserida na estrutura através da função \textit{procura}, se a categoria já existir adiciona mais uma entrada ao contador, senão cria uma nova e insere-a na estrutura. Todas as categorias que obdecerem à expressão regular são capturadas com o \textit{yytext}. 

\begin{verbatim}
@[^{]*	{procura(yytext);}
\end{verbatim}

O restante texto é ignorado com a seguinte expressão: 
\begin{verbatim}
.|\n	{;}
\end{verbatim}

\subsubsection{Alínea b1)}
Esta alínea está dividida em duas partes. A primeira pede que sempre que um campo está entre aspas estas sejam trocadas por chavetas e o nome dos autores deverá apresentar o formato "N. Apelido". 


Para apanhar o conteúdo do campo \textbf{author = }, este que pode iniciar-se com chaveta de abertura ou aspas, sugerimos os seguintes filtros: 


\begin{verbatim}
"author ="[ ]*"\""  {BEGIN (AUT);} 
"author ="[ ]*"\{"  {BEGIN (AUT);} 
\end{verbatim}

Quando num autor se encontrar caracteres especiais no meio do nome tais como chavetas ou aspas, insere esses caracteres no array.

\begin{verbatim}
<AUT>"\}"  {inser(yytext); }
<AUT>"\""  {inser(yytext); }
\end{verbatim}


Implementámos os filtros que nos permitem separar os nomes dos autores, estes que podem estra separados por vírgulas ou \textbf{and}. 
\begin{verbatim}
<AUT>"\,"[ ]+  {trata();funcao();} 
<AUT>[ ]+"and"[ ]+  {trata();funcao();}
<AUT>[ ]+"and"(\n)  {trata();funcao();}
\end{verbatim}


Estes filtros permitem-nos determinar quando um autor termina, tanto com aspas seguida de vírgula ou chaveta seguida de vírgula. 
\begin{verbatim}
<AUT>"\"""\,"     {trata();funcao();print();tmp=NULL;BEGIN  INITIAL;}


<AUT>"\}""\,"     {trata();funcao();print();tmp=NULL;BEGIN INITIAL;}
\end{verbatim}


Este filtro lê todos os caracteres que estão à frente do  campo \textbf{autor =  }, e substitui as aspas por chavetas tanto de abertura como de fecho. 
\begin{verbatim}
<AUT>[ '-}] {inser(yytext); }  
\"[a-zA-Z] 	{printf("{%c", yytext[1]);}
[a-zA-Z]\" 	{printf("%c}", yytext[0]);}
\end{verbatim}

\subsubsection{Alínea b2)}
É pretendido que seja implementada uma ferramenta de pretty-printing que indenta
corretamente cada campo e escreve um autor por linha e coloque sempre no início os campos autor e título.


Macro para encontrar todas as variantes da palavra \textit{author}: 
\begin{verbatim}
auto [Aa][Uu][Tt][Hh][Oo][Rr]
\end{verbatim}


Inicia  a filtragem: 
\begin{verbatim}
.+	{BEGIN INICIO;}
\end{verbatim}


Escreve um autor por linha e identa o ficheiro (.bib): 
\begin{verbatim}
<INICIO>.*[^@]@.*			{ECHO;}
<INICIO>"  "+				{;}
<INICIO>[  ]+"\}"			{;}
<INICIO>{auto}[ ]+"\=".*	{autor(yytext);}
\end{verbatim}

\subsubsection{Alínea c)}

Nesta alínea é pedido que seja construido um grafo que mostre para dado autor todos os autores que publicam com ele. 

Para tal é necessário que seja feita a recolha de todos os nomes dos autores, depois para associá-los utiliza-se a expressão \textit{and} que nos indica quais os autores que teem publicações conjuntas. 


Este filtro tal como o anterior serve para apanhar o conteúdo do campo \textbf{author = } para os dois casos possiveis no ficheiro \textit{.bib}. 
\begin{verbatim}
"author ="[ ]*"\""  {BEGIN (AUT);} 
"author ="[ ]*"\{"  {BEGIN (AUT);} 
\end{verbatim}


Este filtro serve para ignorar a chaveta de fecho que esteja incluida no nome do autor: 
\begin{verbatim}
<AUT>"\}"             {;}
\end{verbatim}


\begin{verbatim}
<AUT>"\,"[ ]+         {trata();}
<AUT>[ ]+"and"[ ]+    {trata();}
<AUT>[ ]+"and"(\n)    {trata();}


<AUT>"\"""\,"         {trata();print();tmp=NULL;BEGIN INITIAL;}
<AUT>"\}""\,"         {trata();print();tmp=NULL;BEGIN INITIAL;}
<AUT>[A-Za-z]         {inser(yytext);}
\end{verbatim}


\subsection{Makefile}
O principal objetivo da Makefile é facilitar a compilação e execução do programa.
Para isso criamos os seguintes ficheiros para cada uma das alineas:

Makefile alinea a)
\begin{verbatim}
----------------------------------------------------------------------------------------
all: ex1

lex.yy.c: ex1.l
lex ex1.l

comp: main.c
gcc lex.yy.c -o ex1

main.c: lex.yy.c

----------------------------------------------------------------------------------------
\end{verbatim}

Makefile alinea b1)

\begin{verbatim}
----------------------------------------------------------------------------------------
all: exb

lex.yy.c: exb.l
lex exb.l

comp: main.c
gcc lex.yy.c -o exb

main.c: lex.yy.c
----------------------------------------------------------------------------------------
\end{verbatim}

Makefile alinea b2)

\begin{verbatim}
----------------------------------------------------------------------------------------
all: exb2

lex.yy.c: exb2.l
lex exb2.l

comp: main.c
gcc lex.yy.c -o exb2

main.c: lex.yy.c
----------------------------------------------------------------------------------------
\end{verbatim}

Makefile alinea c)

\begin{verbatim}
----------------------------------------------------------------------------------------
all: grafo

lex.yy.c: grafo.l
lex grafo.l

comp: main.c
gcc lex.yy.c -o grafo

main.c: lex.yy.c
----------------------------------------------------------------------------------------
\end{verbatim}







\section{Testes realizados e Resultados}
Mostram-se a seguir alguns testes feitos e respectivos resultados obtidos:
\subsection{Testes e Resultados alinea a)}

Utilizámos este ficheiro de teste para testar as diferentes opções que apareciam no ficheiro  

\lstinputlisting{teste.bib}


Mostrámos de seguida o ficheiro \textit{.html} produzido: 
\begin{verbatim}
proceeding -> 1
mastersthesis -> 2
proceedings -> 4
misc -> 61
manual -> 13
incollection -> 6
unpublished -> 15
inproceedings -> 209
article -> 142
phdthesis -> 21
book -> 47
inbook -> 3
techreport -> 140
string -> 31
\end{verbatim}

\subsection{ Resultados alinea b1)}

Mostrámos de seguida um excerto do documento tratado em que se troca um campo que está entre aspas por chavetas e o nome dos autores apresentam o formato "N. Apelido". 


\begin{verbatim}
@book{ASU86a,
author = {A. Aho and  R. Sethi and  J. Ullman},
title = {Compilers Principles, Techniques and Tools},
year = 1986,
publisher = aw,
annote = {compilacao}
}

@book{KR88a,
author = {B. Kernighan and  D. Ritchie},
title ={The C Programming Language},
year = 1988,
publisher = ph
}

@phdthesis{Bou84a,
author = {P. Boullier},
title = {Contribution \`a la Construction Automatique
d'Analyseur Lexicographiques et Syntaxiques},
year = 1984,
school = {Universit\'e d'Orleans},
annote = {compilacao, parsing, sintaxe, trat erros}
}

@phdthesis{Pug88a,
author = {W. Pugh},
title = {Incremental Computation and Incremental Evaluation
of Function Programs},
year = 1988,
school = {Cornell Univ., Dep. of Computer Science},
annote = {compilacao incremental, atributos, ambientes prog}
}

@article{RMT86a,
author = {T. Reps and  C. Marceau and  T. Teitelbaum },
title = {Remote Attribute Updating for Language-based Editors},
journal = {Communications of the ACM},
year = 1986,
month = Sep,
publisher = acm,
annote = {compilacao incremental, atributos,  ambientes prog}
}
\end{verbatim}

\subsection{ Resultados alinea b2)}

Neste desafio era pedida uma ferramenta de pretty-printing que indentasse
corretamente cada campo e escrevesse um autor por linha e colocásse sempre no início os campos autor e título.


Mostrámos de seguida o output do ficheiro, porém não conseguimos cumprir todas as tarefas propostas. 
\begin{verbatim}
@article{RTD83a,
author = Thomas Reps
and Tim Teitelbaum
and A. Demers
title = "Incremental Context-Dependent Analysis for Language-based
Editors",
journal = "ACM Trans. Programming Languages and Systems (TOPLAS)",
pages = "449--477",
year = 1983,
volume = 5,
number = 3,
publisher = acm,
annote = "compilacao incremental, atributos,ambientes prog"


@phdthesis{Rep82a,
author = Thomas Reps
title = "Generating Language-Based Environments",
year = 1982,
school = "Cornell University",
annote = "compilacao incremental, atributos, ambientes prog"


@article{TR81a,
author = Tim Teitelbaum
and Thomas Reps
title = "The Cornell Program Synthesizer: A Syntax-Directed
Programming Environment",
journal = "Communications of the ACM",
year = 1981,
month = Sep,
volume = 24,
number = 9,
publisher = acm,
annote = "compilacao incremental, atributos,ambientes prog"


@phdthesis{Hoo87a,
author = Roger Hoover
title = "Incremental Graph Evaluation",
year = 1987,
month = May,
school = "Cornell University",
annote = "compilacao incremental, atributos, ambientes prog"


@inproceedings{JG82a,
author = Fahimeh Jalili
and Jean Gallier
title = "Building Friendly Parsers",
booktitle = "9th Annual ACM Symp. on Principles of Programming
Languages",
pages = "196--206",
year = 1982,
publisher = acm,
annote = "compilacao, parsing, sintaxe"


@article{Jal85a,
author = Fahimeh Jalili
title = "A General Incremental Evaluator for Attribute Grammars",
journal = "Science of Computer Programming",
pages = "83--96",
year = 1985,
volume = 5,
publisher = nh,
annote = "atributos, compilacao incremental"

\end{verbatim}


\subsection{Resultados alinea c)}
Por lapso nosso, este desafio não ficou concluido, pois devido a má interpretação do enunciado, não temos a geração de um grafo pedido pelo utilizador, mas sim todos os grafos encontrados. 

\begin{figure}[<+htpb+>]
	\centering
	\includegraphics[scale=0.9]{grafoutput}
	\caption{Exemplo de geração de um grafo com os nomes dos autores com recurso à ferramenta \textit{Graph Viz} }
	\label{p1:fig:graph}
\end{figure}



\chapter{Conclusão} \label{concl}

Após a conclusão deste trabalho verificámos que não cumprimos todos os objetivos pedidos no enunciado. 

Na alínea a pressupusemos que as categorias com o mesmo nome e que se diferenciavam apenas em maiúsculas ou minusculas pertenciam à mesma categoria. Pois assim não estariamos a repetir informação. 

Na alinea b2 não conseguimos colocar no início os campos autor e título. 

A alinea c foi implementada pensando que o grafo seria criado com todos os autores. Porém após uma leitura mais atenta verificou-se que seria pedido que o utilizador escolhesse o autor e assim gerar o grafo com os autores que publicam diretamente com ele. 

Como trabalho futuro pretende-se melhorar os algoritmos que permitam um melhor funcionamento dos filtros. 



\appendix
\chapter{Código do Programa}

Lista-se a seguir o código que foi desenvolvido para a alínea a: 

\lstinputlisting{ex1.l}


Lista-se a seguir o código que foi desenvolvido para a alínea b1: 

\lstinputlisting{exb.l}

Lista-se a seguir o código que foi desenvolvido para a alínea b2: 

\lstinputlisting{exb2.l}

Lista-se a seguir o código que foi desenvolvido para a alínea c: 

\lstinputlisting{grafo.l}


\bibliographystyle{alpha}
















\end{document} 