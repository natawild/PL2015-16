%
% Layout retirado de http://www.di.uminho.pt/~prh/curplc09.html#notas
%
\documentclass{report}
\usepackage[portuges]{babel}
%\usepackage[utf8]{inputenc}
\usepackage[latin1]{inputenc}
\usepackage{graphicx}

\usepackage{url}
%\usepackage{alltt}
%\usepackage{fancyvrb}
\usepackage{listings}
%LISTING - GENERAL
\lstset{
	basicstyle=\small,
	numbers=left,
	numberstyle=\tiny,
	numbersep=5pt,
	breaklines=true,
    frame=tB,
	mathescape=true,
	escapeinside={(*@}{@*)}
}
%
%\lstset{ %
%	language=Java,							% choose the language of the code
%	basicstyle=\ttfamily\footnotesize,		% the size of the fonts that are used for the code
%	keywordstyle=\bfseries,					% set the keyword style
%	%numbers=left,							% where to put the line-numbers
%	numberstyle=\scriptsize,				% the size of the fonts that are used for the line-numbers
%	stepnumber=2,							% the step between two line-numbers. If it's 1 each line
%											% will be numbered
%	numbersep=5pt,							% how far the line-numbers are from the code
%	backgroundcolor=\color{white},			% choose the background color. You must add \usepackage{color}
%	showspaces=false,						% show spaces adding particular underscores
%	showstringspaces=false,					% underline spaces within strings
%	showtabs=false,							% show tabs within strings adding particular underscores
%	frame=none,								% adds a frame around the code
%	%abovecaptionskip=-.8em,
%	%belowcaptionskip=.7em,
%	tabsize=2,								% sets default tabsize to 2 spaces
%	captionpos=b,							% sets the caption-position to bottom
%	breaklines=true,						% sets automatic line breaking
%	breakatwhitespace=false,				% sets if automatic breaks should only happen at whitespace
%	title=\lstname,							% show the filename of files included with \lstinputlisting;
%											% also try caption instead of title
%	escapeinside={\%*}{*)},					% if you want to add a comment within your code
%	morekeywords={*,...}					% if you want to add more keywords to the set
%}

\usepackage{xspace}

\parindent=0pt
\parskip=2pt

\setlength{\oddsidemargin}{-1cm}
\setlength{\textwidth}{18cm}
\setlength{\headsep}{-1cm}
\setlength{\textheight}{23cm}

\def\darius{\textsf{Darius}\xspace}
\def\java{\texttt{Java}\xspace}
\def\pe{\emph{Publicação Eletrónica}\xspace}

%%%%\input{LPgeneralDefintions}
\begin{document}
	
	
\begin{titlepage}
	
	
	\begin{minipage}{0.3\textwidth}
		\begin{flushleft} 
			\includegraphics[width=\textwidth]{EENG.jpg}
		\end{flushleft}
	\end{minipage}
	\begin{minipage}{0.6\textwidth}
		\begin{flushright} 
			
			\textsc{Departamento de Engenharia Informática}\\[0.1cm]
			\bfseries Mestrado Integrado em Engenharia Informática \\ [0.1cm]
			\bfseries \textit{Processamento de Linguagens}\\[8mm]
			
		\end{flushright}
	\end{minipage}
	
	\vspace{3cm}
	
	\begin{center}
			\LARGE \textbf{Trabalho 2 }\\[1.5cm]
			
			\LARGE 	\textbf{Compilador de uma LPIS (Linguagem de Programação Imperativa Simples)}\\[1.5cm]
			
		
		{\Large \bfseries Grupo 38\\[2cm] }
		\noindent\begin{minipage}[b]{.2\textwidth}
			\includegraphics[scale=0.18]{celia}
			\small{Célia Figueiredo a67637}
		\end{minipage} 
		\hfill
		\begin{minipage}[b]{.2\textwidth}
			\includegraphics[scale=0.15]{gil}
			\small{Gil Gonçalves a67738}
		\end{minipage}
		\hfill
		\begin{minipage}[b]{.2\textwidth}
			\includegraphics[scale=0.9]{many}
			\small{Diogo Tavares a61044 }
		\end{minipage} 
		\vspace{3ex}
		\vfill
		\large Braga, {\large \today}
		
	\end{center}
\end{titlepage}	



\begin{abstract}
	
Este relatório descreve o processo de desenvolvimento e decisões tomadas para a realização do segundo trabalho prático da Unidade Curricular de Processamento de Linguagens.\\ O problema a resolver consiste na criação de uma linguagem imperativa simples (LPIS) e da respetiva gramatica independente de contexto \textbf{GIC} seguida do desenvolvimento de um compilador para a mesma que gera pseudo-código \textit{Assembly}.


A linguagem desenvolvida foi baseada na linguagem de programação C, e suporta:
\begin{itemize}
	\item Variáveis globais
	\item Ciclos: for, while, do while
	\item Estruturas de Condição: If ... Else
	\item Expressões Aritméticas e lógicas
	\item Funções com argumentos
	\item Declaração de variáveis locais dentro das funções
\end{itemize}

O compilador foi desenvolvido com recurso ao analisador léxico Flex e ao analisador sintático Yacc.

\end{abstract}

\tableofcontents

\chapter{Introdução} \label{intro}

O presente trabalho enquadra-se na unidade curricular de Processamento de Linguagens do MIEI da Universidade do Minho. O trabalho pretende aumentar a experiência em engenharia de linguagens, assim como incentivar o desenvolvimento de processadores de linguagens e compiladores em ambiente Linux. As ferramentas que suportam a sua implementação consistem no conjunto flex-yacc, sendo estes um gerador de analisadores léxicos e um gerador de analisadores sintáticos/semânticos, respetivamente. 


Inicialmente é definida uma linguagem de programação imperativa simples, a qual deve permitir manusear variáveis do tipo inteiro assim como realizar operações básicas. As variáveis devem ser declaradas no início do programa e não pode haver re-declarações. Após a validação da linguagem criada com o docente, é desenvolvido um compilador para esta linguagem, com base na GIC criada e com recurso ao Gerador Yacc/Flex. O compilador da linguagem deve gerar pseudo-código Assembly da Máquina Virtual fornecida.


\section*{Estrutura do Relatório}

A elaboração deste documento teve por base a estrutura do relatório fornecida pelo docente. 
O relatório encontra-se então estruturado da seguinte forma: no Capítulo \ref{intro} é feita uma contextualização ao assunto tratado neste trabalho, seguindo-se uma introdução onde são apresentadas as metas de aprendizagem pretendidas.
Posteriormente, no Capítulo \ref{ae}, é exposto o enunciado do trabalho e a descrição do problema.\\
Imediatamente após, no Capítulo \ref{cdres}, é apresentada a linguagem criada, a gramática correspondente e descrita a forma como foi gerado o código Assembly.
No Capítulo \ref{codtestes} são apresentados os testes realizados e os seus resultados.\\
Por último, no Capítulo \ref{concl}, faz-se uma análise crítica relativa quer ao desenvolvimento do projeto quer ao seu estado final e ainda é feita uma abordagem ao trabalho futuro. No fim do documento estarão incluidos ficheiros anexos com o código desenvolvido. 

\chapter{Análise e Especificação} \label{ae}
\section{Descrição informal do problema - Enunciado}


Pretende-se que comece por definir uma linguagem de programação imperativa simples LPIS, a seu gosto.

Apenas deve ter em consideração que a LPIS terá de permitir:

\begin{itemize}
	\item \emph{declarar e manusear} variáveis atómicas do tipo \emph{inteiro},
	com os quais se podem realizar as habituais operações aritméticas, relacionais e lógicas.
	\item \emph{declarar e manusear} variáveis estruturadas do tipo \emph{array (a 1 ou 2 dimensões) de inteiros}, em relação aos quais é apenas permitida a operação de indexação (índice inteiro).
	\item \emph{efetuar} instruções algorítmicas básicas como a \emph{atribuição de expressões a variáveis}.
	\item \emph{ler} do \emph{standard input} e \emph{escrever} no \emph{standard output}.
	\item \emph{efetuar} instruções para controlo do fluxo de execução--- \emph{condicional} e \emph{cíclica}---que possam ser aninhadas.
	\item \emph{definir e invocar subprogramas} sem parâmetros mas que possam retornar um resultado atómico (opcional).
\end{itemize}

Neste tipo de linguagens, as variáveis deverão ser declaradas no início do programa e não pode haver re-declarações, nem utilizações sem declaração prévia. Se nada for explicitado, o valor da variável após a declaração é 0 (zero).



\section{Descrição do problema}

Como descrito na secção anterior o desafio que nos foi proposto consiste na criação de uma linguagem imperativa simples apenas com as características mais básicas, o desenvolvimento de uma \textbf{GIC} para a mesma e ainda a criação de um compilador gerador de \textbf{pseudo-código} Assembly. \\
Posto isto tivemos então de, primeiramente, pensar e desenhar uma linguagem imperativa ao nosso gosto, seguindo os requisitos pedidos. De seguida foi necessário criarmos uma gramática que a descrevesse e, finalmente, com recurso a essa gramática, tornar possível o armazenamento dos dados vindos de um programa escrito na nossa linguagem necessários à geração do \textbf{pseudo-código} Assembly.




\chapter{Concepção/desenho da Resolução} \label{cdres}

O sistema desenvolvido é constituído por 2 modelos pricipais: gramatica.l e gramatica.y, que são respetivamente o analisador léxico e analisador sintático. 


O analisador sintático utiliza o ficheiro compilador.h, sendo este módulo responsável pelo tratamento das variáveis e funções existentes (adicionar/consultar variáveis).

O sistema utiliza também duas estruturas de dados: uma HashMap e uma Stack. A hashmap é utilizada para guardar as variáveis e as funções, enquanto que a stack permite o controlo das labels dos ciclos durante a compilação.

\paragraph{}
Na Figura \ref{p1:fig:dependencias}, é possível observar as dependências entre os diversos ficheiros, a estrutura do nosso projeto que terá de passar pelo desenvolvimento de um analisador léxico em \textit{Flex} que fará o reconhecimento dos \textit{tokens} que são utilizados no analisador semântico que gera o código \textit{Assembly}.


\begin{figure}[<+htpb+>]
	\centering
	\includegraphics[scale=0.6]{grafodependencias}
	\caption{Esquema de dependências dos ficheiros }
	\label{p1:fig:dependencias}
\end{figure}



\section{Desenho da Linguagem}

O analisador léxico encontra-se desenvolvido com o suporte da função 'yylex' e deteta todos os símbolos terminais da linguagem (palavras reservadas, sinais e variáveis). Este analisador efetua também a deteção de comentários (linhas precedidas pelos símbolos '//'), ignorando o texto neles contidos. De forma a facilitar a deteção os erros de sintaxe, o parser conta as linhas que já interpretou. Este funcionalidade permite ao analisador sintático informar a linha onde ocorrer a anomalia em caso de erro de processamento. 

\subsection{Analisador sintático/semântico}

O analisador sintático/semântico é o responsável por processar os tokens obtidos através do analisador léxico, utilizando as produções definidas para calcular a instrução e escrever no ficheiro output final. O ficheiro onde se encontram as produções denomina-se gramatica.y. 

\begin{description}

\item[Definição dos tokens] \hfill \\

Previamente à definição das produções, estão definidos os diversos tokens assim como o tipo das diferentes variáveis presentes nas produções.

\item[Produções iniciais] \hfill \\

O processamento é iniciado na produção Prog, correspondente ao começo do programa. São realizadas as inserções iniciais no ficheiro de output, e as produções a serem efetuadas podem consistir numa lista de declarações, numa lista de funções, ou numa lista de instruções. Caso se encontre uma lista de declarações, é realizado o controlo de saltos de instruções, através da inserção da instrução "JUMP inicio" no ficheiro de output. Isto possibilita a declaração de variáveis antes da declaração das funções, de forma a que as funções possuam acesso às variáveis globais declaradas.  

\item[Produções de Funções] \hfill \\

A declaração de funções é precedida pelo símbolo terminal '\#', de forma a facilitar a sua leitura e distinção com outras instruções. O armazenamento das funções declaradas é realizado através da utilização de uma hashmap, e permite guardar o contexto destas, ou seja, as declarações efetuadas dentro da função são tidas como variáveis locais, e apenas acessíveis dentro da função. No final da declaração da função, o contexto é encerrado. Por simplicidade, não é possível utilizar chamadas a funções como argumento de outra função.

\item[Produções de declarações] \hfill \\

As declarações de variáveis podem ocorrer dentro de uma função (i.e. variáveis locais) ou fora de qualquer contexto (i.e. variáveis globais). Desta forma, ao declarar uma variável, é efetuado o teste que verifica se está está declarada ou não dentro de uma função. Não será permitido re-declarar variáveis locais com o mesmo nome que variáveis globais já existentes, sendo apresentado um erro quando isso ocorre.

\item[Produções de instruções e atribuições] \hfill \\

São suportadas diversas instruções, destacamos a "return", pois esta instrução calcula o endereço a retornar a partir do número de argumentos de entrada da função na qual se insere e do frame pointer (fp) salvaguardado. 

\item[Produções de input/output] \hfill \\
As produções referentes à leitura e escrita no stdin. A produção de escrita suporta a impressão de expressões, sendo que a produção de leitura armazena as variáveis atribuídas conforme o contexto definido. 

\item[Produções de controlo de fluxo de execução condicional] \hfill \\

A instrução de controlo de fluxo de execução condicional está definida como "IF TestExpLog ConjInst Else", suportando um conjunto de instruções no seu contexto, assim como testes à condição.

\item[Produções de controlo de fluxo de execução cíclico] \hfill \\

As produções correspondentes ao controlo de fluxo de execução cíclico suportam ciclos (while, do...while e for) 'WHILE TestExpLog ConjInst', 'DO ConjInst WHILE TestExpLog' e 'FOR ForHeader ConjInst'. Estas produções são suportadas por uma estrutura de dados (stack), sendo esta a que torna possível calcular os saltos a efetuar.

\item[Produções de cálculo de expressões] \hfill \\

O compilador possui a capacidade de processar expressões aritméticas e lógicas (Exp '=''=' Exp, Exp '+' Termo, Termo '*' Fun) , tanto em forma de declaração como possibilitam também a utilização de parêntesis aninhados.

\end{description}


\section{Desenho da Gramatica}
Após desenhada e descrita a linguagem imperativa que iremos usar, resta transformar todas as regras que definimos sobre ela numa \textbf{GIC}.\\
Os símbolos não-terminais da gramática que definimos são os seguintes: prog, ListaDecla, ListaFun, ListaInst, Funcao, Inst, TipoFun, IdFun, ListaArg, ListaArg2, Tipo, Decla, Var, ConjInst, Atrib, Print, Scan, If, Else, While, DoWhile, For, ForHeader
,ForAtrib, ExpLog, Exp, Termo, Fun, FunArgs, FunArgs2, TestExpLog. 

\paragraph{}
Por sua vez os símbolos terminais são: INT, WHILE, FOR, IF, ELSE, RETURN, VOID, PRINT, SCAN, DO, num, id  ";", , "(",")", "{", "}" , "=", "\#", "[", "]", ">", "<". 

Na concepção da nossa gramática utilizamos em todos os casos recursividade à esquerda.
Segue-se então a gramática gerada:

\begin{verbatim}

Prog        : ListaDecla  ListaFun 	ListInst    		                                                              			
            ; 

ListaDecla  :                            
            | ListaDecla Decla 
            ;

ListaFun    :   
            | ListaFun Funcao 
            ;

ListInst    : Inst                               
            | ListInst Inst                                    
            ;

// --------------------  FUNCAO ------------------------------------
/** A declaração de funções é precedida pelo símbolo terminal '\#'. 
 */

Funcao      : '#' TipoFun IdFun  '(' ListaArg ')' '{' ListaDecla ListInst '}'             
            ;

TipoFun     : VOID      	                   
            | INT                      
            ;  

IdFun 		: id 
			;

ListaArg    :   
            | ListaArg2 ;

ListaArg2   : Tipo Var                            
            | ListaArg2  ','  Tipo Var         
            ;

Tipo 		: INT                
			; 

// --------------------DECLARACAO ------------------------------------

Decla       : INT Var ';'                            		                
            | INT Var '[' num ']' ';'   
            | INT Var '[' num ']' '[' num ']' ';'                                                     
            ;

Var 		: id              
			;

// --------------------INSTRUCAO ------------------------------------

ConjInst    :   
            |'{' ListInst '}'               
            ;

Inst        : If                                                                  
            | While                                     
            | DoWhile
            | For                                       
            | Atrib ';'                                 
            | Print';' 							                               
            | Scan ';'                                 
            | RETURN Exp ';'     
            | ELSE                                 
            ;

// ------------------------------------ ATRIBUIÇAO ------------------------------------

Atrib       : Var '=' Exp                                                                                      
            | Var '+''+'                                                                                       
            | Var'[' Exp ']' '=' Exp  
            | Var'[' Exp ']' '[' Exp ']' '=' Exp  
            ;

// ------------------------------------ PRINT SCAN ------------------------------------

Print:     PRINT '(' Exp ')'  		                  
            ;

Scan:      SCAN '(' Var')'   		                                
            ;
// ------------------------------------ IF THEN ELSE ------------------------------------

If          :  IF  TestExpLog  ConjInst Else
            ;

Else        :       
            | ELSE ConjInst 
            ;

// ------------------------------------# WHILE ---------------------------------------------

While       : WHILE TestExpLog ConjInst                                    
            ;

// ------------------------------------# DO WHILE ---------------------------------------------

DoWhile     : DO ConjInst WHILE TestExpLog ';'              
            ;
    
// ------------------------------------# FOR ---------------------------------------------

For         : FOR ForHeader ConjInst                      
            ;

ForHeader   :  '(' ForAtrib ';' ExpLog ';' ForAtrib ')' 
            ;  

ForAtrib    : Atrib  
            ;

// --------------------------------CALCULO DE EXPRESSOES ------------------------------------
ExpLog 		: Exp 
			|Exp '=''=' Exp 		
			|Exp '!''=' Exp
			|Exp '>''=' Exp 		
			|Exp '<''=' Exp 		
			|Exp '<' Exp 			
			|Exp '>' Exp 			
			; 

Exp 		: Termo
			|Exp '+' Termo  			
			|Exp  '-' Termo 			
			|Exp '|''|' ExpLog 
			; 

Termo		: Fun
			| Termo '/' Fun 			
			| Termo '*' Fun 			
			| Termo '&''&' ExpLog
			; 

Fun 	   	: num                         
            | Var  											                         
            | Var '['Exp ']'                                           
            | Var  '['Exp ']' '['Exp ']'                                      
            | IdFun '(' FunArgs')' 
            | '(' Exp ')'                  
            ;                                  

FunArgs     :    
            | FunArgs2 
            ;

FunArgs2    : Exp                                
            | FunArgs2 ',' Exp                 
            ;

TestExpLog  : '(' ExpLog ')'                                        
            ;
\end{verbatim}


\section{Geração de Pseudo-Código Assembly}\label{assembly}

Para gerar o código Assembly do programa é necessário definir ações semânticas no \textit{YACC}. Estas ações semânticas são blocos de código C que são executados aquando o reconhecimento da expressão que os antecede. Assim sendo, é realizada uma tradução da linguagem desenvolvida para a linguagem \emph{assembly} da VM, à medida que cada instrução ou expressão é identificada.

\subsection{Declaração das variáveis}
\paragraph{}

Na parte das declarações de variáveis é necessário inseri-las na estrutura que críamos e gerar o código Assembly para alocar memória para elas. Para isso decidimos usar variáveis globais para guardar o tamanho, o endereço, o tipo e o nome de uma variável. Sempre que o analisador sintático  reconhece uma declaração de um inteiro coloca a variável correspondente a 1 e se reconhecer um \textit{array} a 1 ou 2 dimensões coloca nessa mesma variável o seu tamanho. Da mesma forma é atualizada a variável correspondente ao tipo.

\paragraph{}
Quanto à variável correspondente ao endereço é uma variável global com valor inicial de 0, que é incrementada sempre que uma nova variável é adicionada com sucesso à estrutura. Quando é encontrado o nome de uma variável já tem então guardado o seu tamanho e tipo e encontra-se em condições de guardá-la na estrutura de dados. Nesta altura é feita a verificação da existência de uma variável com o mesmo nome ou não. Caso já exista, o programa termina e é gerada uma mensagem de erro. Caso contrário é gerado o código Assembly para empilhar a variável na \textit{Stack}: PUSHN X, em que X é o tamanho da variável. De seguida é incrementada a variável do endereço tantas vezes quanto o tamanho da variável.
\subsection{Inicio do programa e variáveis }
\paragraph{}
Após todas as declarações terem sido reconhecidas é gerada a instrução Assembly START que indica o início das instruções do programa.

\paragraph{}
Em todas as instruções, sempre que é encontrada uma variável é feita a verificação da sua existência na estrutura. Se não existir o programa termina com um erro. Se existir, é guardado o seu registo para ser utilizado no código Assembly. No caso de se tratar de um acesso a uma posição de um \textit{array} é também feita a verificação do seu tipo.


\subsection{Atribuição e operações lógicas}
\paragraph{}
Nas instruções de atribuição o código Assembly gerado, no caso de ser uma variável inteira escalar, é apenas um STOREG X, em que X é o endereço da variável em questão. No caso de ser um acesso a um vetor, é necessário aquando do reconhecimento do nome da variável efetuar um PUSHGP seguido de um PUSHI X, em que X é o endereço da variável em causa, e de um PADD. De seguida, após o reconhecimento das expressões constituintes da atribuição é gerado um STOREN.\\


Para as expressões, termos e condições que utilizam operadores aditivos, multiplicativos e relacionais, respetivamente, foi feito o reconhecimento de que operador estava a ser utilizado, e tendo em conta isso gerado o código Assembly respetivo a essa operação. De notar que não existe uma instrução Assembly para as operações lógicas e e ou, logo utilizamos a multiplicação e a soma, respetivamente, para representá-las.\\

\subsection{Escrita}
\paragraph{}
Para as instruções de escrita o único código Assembly necessário é um WRITEI.\\
Para as instruções de leitura, no caso de a leitura ser feita para uma variável escalar, é gerado o código READ para ler uma\textit{string} do teclado, seguido do código ATOI para transformá-la num inteiro, e de seguida guardá-la no endereço da variável em questão com a instrução STOREG X, em que X é o endereço. Já no caso de se tratar de um vetor é necessário um PUSHGP seguido de um PUSHIX e de um PADD antes de proceder à leitura em si, que se dá da mesma forma que no caso do escalar, mas substituindo o STOREG por um STOREN.\\

\subsection{Condicional}
Quando às instruções condicionais, recorrendo também às \textit{labels}, e aos \textit{jumps} seguimos a seguinte lógica: após a condição do \textit{if} temos um JZ para o início do bloco \textit{else} caso este exista e para o fim do \textit{if} caso contrário.


\subsection{Ciclos}
No caso dos ciclos utilizamos \textit{labels} para marcar o início e o fim de um ciclo. Depois de reconhecida a expressão da condição do ciclo fazemos um JZ (salta se a expressão for falsa) para a \textit{label} do fim de ciclo. No fim do ciclo temos um JUMP não condicional que salta sempre para o início do ciclo (antes da condição).\\


No ciclo 'for', é necessária a utilização de instruções 'JUMP', de forma a ser possível seguir o seu fluxo de execução normal. Após a identificação e execução das ações associadas à expressão lógica presente no ciclo 'for', é gerado o salto condicional respetivo, assim como um salto para as instruções associadas ao corpo do ciclo. Além disso, é gerada uma \emph{label} que irá corresponder ao incremento do ciclo que irá ser identificado de seguida. Identificado o final do corpo do ciclo, é efetuado um salto para a \emph{label} correspondente ao incremento do ciclo, que para além das respetivas instruções, conterá outro 'JUMP' para o teste da expressão lógica.


\subsection{Funções}

De forma a implementar adequadamente o processamento de funções, é necessário resolver certas implicações, sendo que esta funcionalidade obriga a tratar de diversos contextos dentro do programa (global e local).

As declarações das funções são efetuadas após as declarações das variáveis globais para que dentro das funções seja possível aceder às variáveis globais.

As declarações de variáveis são feitas no inicio da função, e no hashtable das variáveis é guardado não apenas o endereço mas também o contexto (local ou global). Desta forma, no acesso às variáveis, utiliza-se 'PUSHG' ou 'PUSHL' seja respetivamente variável global ou local.

A passagem de argumentos para a função é tratada como uma declaração especial na qual o endereço é negativo. Já o retorno da função é colocado também num endereço negativo que foi previamente alocado na chamada da função.

Em forma de exemplo, assumindo a chamada de uma função com 2 argumentos, os endereços são negativos ao fp, e o endereço onde a função colocará o retorno é $fp - 3$.
Após a execução da função é feito o 'pop' dos argumentos e assim o valor de retorno da função está no topo da stack. 


\section{Estruturas de Dados}
\subsection{Stack}

De forma a evitar confusão na atribuição de \emph{labels} relativas a \emph{ifs} e \emph{loops} é utilizado um contador de condições. À medida que é encontrada uma instrução que implique o uso de uma condição, este contador é incrementado e o seu valor é colocado numa stack. Deste modo, o valor que se encontra no topo da stack é relativo ao último \emph{ciclo/if} encontrado. Sempre que é encontrado o final de uma condição, o valor no topo da stack é removido. Através do uso de um contador e de uma stack, é mais simples gerir as \emph{labels} e as operações de controlo, como \emph{JUMPs} e \emph{JZs}.
A stack utilizada implementa apenas as funções necessárias para a sua inicialização, inserção, remoção e consulta. Com as operações de push/pop são inseridos/removidos valores no topo da stack, e com a operação de get apenas é consultado o valor no topo da stack, sem que este seja removido. Esta última operação é útil para a geração de instruções 'JZ' na geração de código VM.


\subsection{HashMap}

Como foi referido anteriormente, é utilizada uma \emph{hashmap} com o objetivo de guardar as variáveis e as funções. Quanto às variáveis, é necessário guardar e aceder a informação como o seu endereço e tipo. Sendo assim, foi criada uma estrutura de dados auxiliar para armazenar essa informação. O nome da variável é utilizado como chave e, a partir dela, conseguimos aceder à sua informação correspondente na hashmap. 
Relativamente às funções, é necessário guardar e aceder a informação como o seu nome, informação relativa aos seus argumentos de entrada e o tipo de dados de saída. Para esse feito, também foram necessárias estruturas de dados auxiliares como uma lista ligada capaz de armazenar informação relativa aos argumentos de entrada e uma outra que contem a informação relativa ao tipo de dados de saída, dados de entrada e nome da função. Neste caso, o nome da função funciona como chave na \emph{hashmap} e o seu valor é a estrutura que contem a informação mais geral sobre a função.
A \emph{hashmap} utilizada implementa funções necessárias para a sua inicialização, inserção, remoção e consulta, sendo que também contém outras funções que não foram utilizadas no desenvolvimento deste projeto.


\chapter{Codificação e Testes} \label{codtestes}

\section{Alternativas, Decisões e Problemas de Implementação}

\subsection{Makefile}
O principal objetivo da Makefile é facilitar a compilação e execução do programa.
Para isso criamos o seguinte ficheiro: 

\begin{verbatim}

gramatica: y.tab.c lex.yy.c stack.o compilador.o hashmap.o
		gcc -o gramatica y.tab.c stack.c compilador.c hashmap.c

lex.yy.c: gramatica.l 
			flex gramatica.l

y.tab.c: gramatica.y
			yacc -d gramatica.y

stack.o: stack.c stack.h
			gcc -c stack.c 
compilador.o :	compilador.c compilador.h 
			gcc -c compilador.c
hashmap.o: hashmap.c hashmap.h
			gcc -c hashmap.c

clean: 
	rm  *.o lex.yy.c y.tab.c y.tab.h gramatica
\end{verbatim}


\section{Testes realizados e Resultados}

\subsection{Teste 1}
\subsubsection{input}
Lidos 3 números, escrever o maior deles
\lstinputlisting{./testes/teste1.txt} 
\subsubsection{output}
\lstinputlisting{./testes/assemblyteste1.vm} 

\subsection{Teste 2}
\subsubsection{input}
ler N (valor dado) números e calcular e imprimir o seu somatório deles
\lstinputlisting{./testes/teste2.txt} 
\subsubsection{output}
\lstinputlisting{./testes/assemblyteste2.vm} 

\subsection{Teste 3}

\subsubsection{input}
Contar e imprimir os números pares de uma sequência de N números dados.
\lstinputlisting{./testes/teste3.txt} 
\subsubsection{output}
\lstinputlisting{./testes/assemblyteste3.vm} 

\subsection{Teste 4}
\subsubsection{input}
Ler e armazenar os elementos de um vetor de comprimento N; imprimir os valores por ordem crescente após fazer a ordenação do array por trocas diretas.
\lstinputlisting{./testes/teste1.txt} 
\subsubsection{output}
\lstinputlisting{./testes/assemblyteste1.vm} 

\subsection{Teste 5}
\subsubsection{input}
Ler e armazenar os elementos de uma matriz NxM; calcular e imprimir a média e máximo dessa matriz
\lstinputlisting{./testes/teste1.txt} 
\subsubsection{output}
\lstinputlisting{./testes/assemblyteste1.vm} 

\subsection{Teste 6}
\subsubsection{input}
Invocar e usar num programa seu uma funçãoo ?potencia(Base,Exp)? cujo código Assembly lhe será fornecido
\lstinputlisting{./testes/teste1.txt} 
\subsubsection{output}
\lstinputlisting{./testes/assemblyteste1.vm} 


\chapter{Conclusão} \label{concl}

Após descrito todo o processo de desenvolvimento deste trabalho, desde o desenho da linguagem até à geração do código Assembly, passando pela construção da gramática, e apresentados os testes e respetivos resultados resta apresentar uma breve conclusão sobre todo o processo.

Atualmente o projeto encontra-se totalmente funcional: recebendo um ficheiro com um programa escrito na nossa linguagem gera sempre as instruções Assembly.
Um dos principais pontos positivos consiste na implementação do processamento e compilação de funções, sendo esta a funcionalidade mais trabalhosa e sobre a qual recaiu maior parte do tempo despendido. 

A implementação das expressões de controlo de execução possuíram também uma dificuldade acrescida, obrigando à utilização de estruturas de dados mais complexas, tais como hashmaps e stacks. 

Para finalizar alcançamos os objetivos definidos aquando da proposta do trabalho, tendo-se desenvolvido um compilador capaz de processar uma LPIS, com a possibilidade de dar feedback sobre o código de input definido e criar o ficheiro com instruções em Assembly correspondentes.

Uma dificuldade apresentada pelo grupo foi a implementação da funcionalidade dos arrays de duas dimensões, pois sendo muito semlhante aos arrays de uma dimensão foi mais complicado entender os acessos à 

\appendix
\chapter{Código Flex}
\lstinputlisting{gramatica.l} 
\chapter{Código Yacc}
\begin{verbatim}
%{ 
#include "compilador.h"
#include <stdio.h>
#include <string.h>
#include "stack.h"
#include <stdlib.h>
#include "y.tab.h"

extern ccLine;
static int total;
FILE *f;
static Stack s;

%}

%union{
char* var_nome;
int valor;
Tipo tipo;
struct sVarAtr
{
char* var_nome;
int valor;
int size;
} varAtr;   
}


%token INT WHILE FOR IF ELSE RETURN VOID PRINT SCAN DO
%token <valor>num 
%token <var_nome>id 

%type <tipo> TipoFun
%type <tipo> Tipo
%type <var_nome> IdFun
%type <varAtr> Var




// --------------------PROGRAMA ------------------------------------
/**
Um programa é uma lista de declarações, lista de Funcões , e uma lista de Instruções 
*/

%%

Prog       :                    
ListaDecla          {fprintf(f,"start\n");fprintf(f,"jump inicio\n");}	 	
ListaFun 			{fprintf(f,"inicio:nop\n");}        		
ListInst    		{fprintf(f,"stop\n");}                                                         

; 

ListaDecla  :                            
| ListaDecla Decla 
;

ListaFun    :   
| ListaFun Funcao 
;

ListInst    : Inst                               
| ListInst Inst                                    
;

// --------------------  FUNCAO ------------------------------------
/** A declaração de funções é precedida pelo símbolo terminal '\#'. 
*/

Funcao      : '#' TipoFun IdFun                 {inserFuncao($2,$3);}
'(' ListaArg ')' 
'{' ListaDecla ListInst '}'     {fim();}        
;

TipoFun     : VOID      	        {$$ =_VOID;}              
| INT                   {$$ =_INTS;}        
;  

IdFun 		: id 
;

ListaArg    :   
| ListaArg2 ;

ListaArg2   : Tipo Var                            
| ListaArg2  ','  Tipo Var         
;

Tipo 		: INT                 {$$ =_INTS;} 
; 


// --------------------DECLARACAO ------------------------------------

Decla       : INT id ';'                               {decVar($2,1,'S');fprintf(f,"pushi 0\n"); vars++; }   			                
| INT id '[' num ']' ';'                   {if(testeColuna($4)==1) 
{decVar($2,$4,'A');fprintf(f,"pushn%d\n",$4);}
else {yyerror("Tamanho menor que 1");}
}
| INT id '[' num ']' '[' num ']' ';'       {if(testeMatriz($4,$7)==1) 
{decVar($2,$4*$7,'M');fprintf(f,"pushn %d\n",$4*$7);}
else {yyerror("Tamanho menor que 1");}        
}  

;


Var 		: id                                      {Endereco a=getEndereco($1); $$.var_nome=strdup($1); $$.valor=1;}
;

// --------------------INSTRUCAO ------------------------------------

ConjInst    :                                       
|'{' ListInst '}'                   
;

Inst        : If                                                                  
| While                                     
| DoWhile
| For                                       
| Atrib ';'                                 
| Print';' 							                               
| Scan ';'                                 
| RETURN Exp ';'     {fprintf(f,"storel %d\n",decFunRetAddr());fprintf(f,"return\n");}
| ELSE               { yyerror("'Else' sem um 'If' anteriormente");return 0;}                          
;

// ------------------------------------ ATRIBUIÇAO ------------------------------------

Atrib       : Var '=' Exp                       {Endereco a = getEndereco($1.var_nome); 
if(a.tipo == _INTS){ fprintf(f,"store%c %d\n",a.tipoVar, a.addr);} 
else {yyerror("Tipos incompativeis");return 0;  }  
} 

| Var '+''+'                        {Endereco a = getEndereco($1.var_nome); 
if(a.tipo ==_INTS){fprintf(f,"pushi 1\n push%c %d\n add\n store%c %d\n",a.tipoVar,a.addr, a.tipoVar, a.addr);}
else{yyerror("Tipos incompativeis"); return 0; } 
}    

| Var'[' Exp ']' '=' Exp            {Endereco a = getEndereco($1.var_nome); fprintf(f, "push%cp \n push%c %d padd\n",(a.tipoVar=='l')? 'f' : 'g', 
a.tipoVar, a.addr); fprintf(f, "storen\n");}


| Var'[' Exp ']' '[' Exp ']' '=' Exp  {Endereco a = getEndereco($1.var_nome); fprintf(f, "push%cp \n push%c %d padd\n",(a.tipoVar=='l')? 'f' : 'g', 
a.tipoVar, a.addr);}
;

// ------------------------------------ PRINT SCAN ------------------------------------

Print:     PRINT '(' Exp ')'  		{fprintf(f,"writei\n");}                        
;

Scan:      SCAN '(' Var')'   		{Endereco a= getEndereco($3.var_nome); fprintf(f,"read\n atoi\n store%c %d\n",a.tipoVar, a.addr);}                                 
;
// ------------------------------------ IF THEN ELSE ------------------------------------

If          :  IF                   {total++; push(s,total);}
TestExpLog   	        {fprintf(f,"jz endCond%d\n", get(s));}
ConjInst  		        {fprintf(f," endCond%d\n", pop(s));}	
Else
;

Else        :       
| ELSE ConjInst 
;

// ------------------------------------# WHILE ---------------------------------------------

While       : WHILE             {total++; push(s,total); fprintf(f, "ciclo%d: NOP\n", get(s));}
TestExpLog          {fprintf(f, "jz endciclo%d\n", get(s)); }
ConjInst            {fprintf(f, "jump ciclo%d\n endCiclo%d\n", get(s), get(s));  pop(s); }                                
;

// ------------------------------------# DO WHILE ---------------------------------------------

DoWhile     : DO                            {total++; push(s,total); fprintf(f, "ciclo%d: NOP\n", get(s));}    
ConjInst WHILE TestExpLog ';'   {fprintf(f, "jz endciclo%d\n jump ciclo%d\n endciclo%d: NOP\n", get(s),get(s),get(s));pop(s);}      
;

// ------------------------------------# FOR ---------------------------------------------

For         : FOR ForHeader ConjInst     {fprintf(f,"jump ciclo%dA\nendciclo%d\n", get(s), get(s)); pop(s);}                  
;

ForHeader   :  '(' ForAtrib ';'         {total++; push(s,total); fprintf(f,"ciclo%d: nop\n", get(s));}
ExpLog ';'                 {fprintf(f,"jz endciclo%d\njump ciclo%dB\nciclo%dA: nop\n", get(s), get(s), get(s));}
ForAtrib ')'               {fprintf(f,"jump ciclo%d\nciclo%dB: nop\n", get(s), get(s));}
; 


ForAtrib    : Atrib  
;

// -----------------------------------------------------------------CALCULO DE EXPRESSOES -------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ExpLog 		: Exp 
|Exp '=''=' Exp 		{fprintf(f,"equal\n");}
|Exp '!''=' Exp         {fprintf(f,"equal\npushi 0\nequal\n");}
|Exp '>''=' Exp 		{fprintf(f,"supeq\n");}
|Exp '<''=' Exp 		{fprintf(f,"infeq\n");}
|Exp '<' Exp 			{fprintf(f,"inf\n");}
|Exp '>' Exp 			{fprintf(f,"sup\n");}
; 


Exp 		: Termo
|Exp '+' Termo  			{fprintf(f,"add\n");}
|Exp  '-' Termo 			{fprintf(f,"sub\n");}
|Exp '|''|' ExpLog          {fprintf(f, "add\n jz endCond%d:nop\n",get(s));}
; 


Termo		: Fun
| Termo '/' Fun 			{fprintf(f,"div\n");}
| Termo '*' Fun 			{fprintf(f,"mul\n");}
| Termo '&''&' ExpLog       {fprintf(f, "pushi 1\nequal\njz endCond%d: nop\n",get(s));}
; 

Fun 	   	: num                       {fprintf(f, "pushi %d\n",$1 );}           
| Var  	                    {Endereco a = getEndereco($1.var_nome); fprintf(f, "push%c %d\n",a.tipoVar, a.addr);} 	

| Var '['Exp ']'            {Endereco a = getEndereco($1.var_nome); 
fprintf(f, "push%cp\npush%c %d\npadd\n",(a.tipoVar=='l')?'f':'g', a.tipoVar, a.addr);
fprintf(f, "loadn\n");}  

| Var  '['Exp ']' '['Exp ']'                                      
| IdFun                     {funcaoExiste($1); fprintf(f, "pushi 0\n");}
'(' FunArgs')'              {fprintf(f, "call %s\n",$1); fprintf(f, "pop%d\n",numeroArgumentos());}

| '(' Exp ')'                  
;                                  

FunArgs     :    
| FunArgs2 
;

FunArgs2    : Exp                   {proximoArgumento(_INTS);}                            
| FunArgs2 ',' Exp      {proximoArgumento(_INTS);}             
;

TestExpLog  : '(' ExpLog ')'                                        
;


%%

int testeMatriz(int linha, int coluna) {

if(linha<=0) {

return -1;
}

else {
if(coluna<=0) {


return -1;

}

else return 1;


}
}

int testeColuna(int linha) {

if(linha<=0) {

return -1;
}

else return 1;
}



#include "lex.yy.c"



/*
int yyerror(char* s) {
printf("\n\x1b[10;01m%s (line %d) \x1b[0m\n", s, yylineno);
return 0;
}
*/


int yyerror(char *s) {

fprintf(stderr,"ERRO: Syntax LINHA: %d MSG: %s\n",ccLine,s);
return 0;
}


/*

int  yyerror(char *s){
fprintf(stderr,"ERRO: Syntax LINHA: %d MSG: %s\n",ccLine,s);
exit(0);
return 0; 
}

*/

/*

void inicio()
{
s = initStack();
total = 0;
f = fopen("assembly.out", "w");
}
*/


int main(int argc, char* argv[]){
total=0; 
lvars=0;
vars=0;
initVGlobalMap(); 
s=initStack();

f=fopen("assembly.txt","w+");
yyparse();
fclose(f); 
free(s);
return 0; 
}

\end{verbatim}

\chapter{Código do Programa}
\begin{verbatim}
#ifndef __COMPILADOR_H__
#define __COMPILADOR_H__

typedef struct variavel *Variavel;

typedef struct funcao *Funcao;

typedef enum eTipo{_VOID,_INTS,_INTA,_INTM}Tipo;

typedef struct sEndereco{
int addr;
char tipoVar;
Tipo tipo;
} Endereco;

int initVGlobalMap();
Funcao existeFuncao(char * func);
int inserFuncao(Tipo tipo,char * name);
int decVar(char* varName, int linha,char tipo);
int decArgumentos(char * nome);
int funcaoExiste(char * nome);
int proximoArgumento(Tipo type);
int numeroArgumentos();
void fim();
void decFunArgRefresh();
int decFunRetAddr();

Endereco getEndereco(char * varName);
\end{verbatim}


\bibliographystyle{alpha}



\end{document} 